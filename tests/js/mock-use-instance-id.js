/**
 * WordPress dependencies
 */
import { useMemo } from '@wordpress/element';
import { useInstanceId } from '@wordpress/compose';

let instanceMap;

/**
 * Creates a new ID for a given object.
 *
 * This uses a `Map` to track object instances, as opposed to the `WeakMap` used in the original `useInstanceId()` from @wordpress/compose.
 * Using a regular `Map` to track objects will ensure they are not unpredictably garbage collected during tests, which can cause the
 * generated instance IDs to change, with resulting test failures.
 *
 * @since n.e.x.t
 *
 * @param {Object} object Object reference to create an id for.
 * @return {number} The new id.
 */
function createID( object ) {
	const instances = instanceMap.get( object ) || 0;
	instanceMap.set( object, instances + 1 );
	return instances;
}

/**
 * Provides a unique instance ID.
 *
 * @since n.e.x.t
 *
 * @param {Object} object Object reference to create an id for.
 * @param {string} prefix Prefix for the unique id.
 * @return {string} The unique id.
 */
function useInstanceID( object, prefix ) {
	return useMemo( () => {
		const id = createID( object );
		return prefix ? `${ prefix }-${ id }` : id;
	}, [ object, prefix ] );
}

/**
 * Mocks the `useInstanceId()` hook.
 *
 * This is necessary to ensure that the instance IDs generated by the hook are predictable during tests.
 *
 * @since n.e.x.t
 */
export function mockUseInstanceID() {
	beforeAll( () => {
		// Note that `useInstanceId()` is a Jest spy, having been spied on in the global `@wordpress/compose` mock.
		useInstanceId.mockImplementation( useInstanceID );
	} );

	beforeEach( () => {
		instanceMap = new Map();
	} );

	afterEach( () => {
		// Clear the cached object instances after each test to avoid memory leaks.
		instanceMap = undefined;
	} );

	afterAll( () => {
		useInstanceId.mockRestore();
	} );
}
